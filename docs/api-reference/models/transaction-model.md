# TransactionModel

Represents a financial transaction (debit or credit) in Centabit.

## Overview

`TransactionModel` is an immutable domain model representing a single financial transaction. Transactions can be linked to categories and budgets for tracking and reporting.

**Location:** `lib/data/models/transaction_model.dart`

## Properties

### Core Fields

#### `id` (String, required)
Unique identifier (UUID v4).

Auto-generated by `.create()` factory. Used for lookups and relationship links.

```dart
final id = transaction.id; // "f47ac10b-58cc-4372-a567-0e02b2c3d479"
```

#### `name` (String, required)
Transaction description or title.

```dart
final name = transaction.name; // "Grocery Shopping"
```

#### `amount` (double, required)
Transaction amount in currency units.

Always positive. The `type` field determines debit vs credit.

```dart
final amount = transaction.amount; // 45.50
```

#### `type` (TransactionType, required)
Transaction direction: `debit` (spending) or `credit` (income).

**Enum values:**
- `TransactionType.debit` - Spending transaction (most common)
- `TransactionType.credit` - Income transaction (reduces net spending)

```dart
final type = transaction.type; // TransactionType.debit
```

#### `transactionDate` (DateTime, required)
Date and time when transaction occurred.

Used for:
- Filtering transactions by date range
- Budget period matching
- Chronological sorting

```dart
final date = transaction.transactionDate; // 2024-12-15 14:32:00
```

### Optional Relationship Fields

#### `categoryId` (String?, nullable)
Links to CategoryModel.

**Null semantics:**
- `null` = Uncategorized transaction
- Non-null = Linked to specific category

```dart
// Categorized
final transaction = TransactionModel.create(
  name: 'Coffee',
  amount: 5.50,
  type: TransactionType.debit,
  categoryId: diningCategoryId,
);

// Uncategorized
final uncategorized = TransactionModel.create(
  name: 'Miscellaneous',
  amount: 10.00,
  type: TransactionType.debit,
  categoryId: null, // No category
);
```

#### `budgetId` (String?, nullable)
Links to BudgetModel.

**Null semantics:**
- `null` = Unassigned/deallocated transaction (intentionally excluded from budgets)
- Non-null = Explicitly assigned to a budget

**Important:** Transactions with `budgetId == null` do NOT count toward any budget's spending calculations.

```dart
// Budgeted
final budgeted = TransactionModel.create(
  name: 'Groceries',
  amount: 45.50,
  type: TransactionType.debit,
  budgetId: decemberBudgetId,
);

// Unassigned (excluded from budget tracking)
final unassigned = TransactionModel.create(
  name: 'One-time expense',
  amount: 200.00,
  type: TransactionType.debit,
  budgetId: null, // Won't count in any budget
);
```

#### `notes` (String?, nullable)
Optional transaction notes or description.

Used for additional context, receipt numbers, or user comments.

```dart
final transaction = TransactionModel.create(
  name: 'Gas',
  amount: 40.00,
  type: TransactionType.debit,
  notes: 'Shell station - highway stop',
);
```

### Timestamp Fields

#### `createdAt` (DateTime, required)
Timestamp when transaction was created.

Auto-generated by `.create()` factory. Immutable after creation.

#### `updatedAt` (DateTime, required)
Timestamp when transaction was last modified.

Auto-generated by `.create()`. Updated automatically on `.copyWith()` in repository layer.

## Factory Constructors

### `TransactionModel.create()`

Creates a new transaction with auto-generated ID and timestamps.

**Signature:**
```dart
factory TransactionModel.create({
  required String name,
  required double amount,
  required TransactionType type,
  DateTime? transactionDate,
  String? categoryId,
  String? budgetId,
  String? notes,
})
```

**Parameters:**
- `name` - Transaction description (required)
- `amount` - Transaction amount, always positive (required)
- `type` - `TransactionType.debit` or `TransactionType.credit` (required)
- `transactionDate` - When transaction occurred (defaults to `DateTime.now()`)
- `categoryId` - Category link (defaults to `null`)
- `budgetId` - Budget link (defaults to `null`)
- `notes` - Additional notes (defaults to `null`)

**Auto-generated:**
- `id` - New UUID v4
- `createdAt` - Current timestamp
- `updatedAt` - Current timestamp

**Example:**
```dart
// Minimal transaction
final minimal = TransactionModel.create(
  name: 'Coffee',
  amount: 5.50,
  type: TransactionType.debit,
);

// Full transaction with all fields
final full = TransactionModel.create(
  name: 'Grocery Shopping',
  amount: 125.50,
  type: TransactionType.debit,
  transactionDate: DateTime(2024, 12, 15, 14, 30),
  categoryId: groceryCategoryId,
  budgetId: decemberBudgetId,
  notes: 'Weekly groceries - Safeway',
);

// Income transaction (credit)
final income = TransactionModel.create(
  name: 'Freelance Payment',
  amount: 500.00,
  type: TransactionType.credit,
  notes: 'Client ABC - Invoice #123',
);
```

### `TransactionModel.fromJson()`

Deserializes transaction from JSON map.

**Signature:**
```dart
factory TransactionModel.fromJson(Map<String, dynamic> json)
```

**Example:**
```dart
final json = {
  'id': 'f47ac10b-58cc-4372-a567-0e02b2c3d479',
  'name': 'Coffee',
  'amount': 5.50,
  'type': 'debit',
  'transactionDate': '2024-12-15T14:32:00.000Z',
  'categoryId': 'cat-123',
  'budgetId': null,
  'notes': null,
  'createdAt': '2024-12-15T14:32:00.000Z',
  'updatedAt': '2024-12-15T14:32:00.000Z',
};

final transaction = TransactionModel.fromJson(json);
```

## Methods

### `toJson()`

Serializes transaction to JSON map.

**Signature:**
```dart
Map<String, dynamic> toJson()
```

**Example:**
```dart
final json = transaction.toJson();
// {
//   'id': '...',
//   'name': 'Coffee',
//   'amount': 5.50,
//   'type': 'debit',
//   ...
// }
```

### `copyWith()`

Creates a copy with modified fields (Freezed-generated).

**Signature:**
```dart
TransactionModel copyWith({
  String? id,
  String? name,
  double? amount,
  String? categoryId,
  String? budgetId,
  DateTime? transactionDate,
  TransactionType? type,
  String? notes,
  DateTime? createdAt,
  DateTime? updatedAt,
})
```

**Example:**
```dart
// Update amount
final updated = transaction.copyWith(amount: 50.00);

// Change category
final recategorized = transaction.copyWith(categoryId: newCategoryId);

// Assign to budget
final assigned = transaction.copyWith(budgetId: budgetId);

// Deallocate from budget
final deallocated = transaction.copyWith(budgetId: null);
```

**Note:** Repository layer automatically updates `updatedAt` on modifications.

## TransactionType Enum

```dart
enum TransactionType { credit, debit }
```

### `TransactionType.debit`
Spending transaction (default).

Increases net spending in calculations. Most common transaction type.

### `TransactionType.credit`
Income transaction.

Reduces net spending in calculations. Used for income, refunds, or reimbursements.

**Usage Example:**
```dart
// Calculate total spent (considering credits)
final totalSpent = transactions.fold<double>(0, (sum, tx) {
  if (tx.type == TransactionType.credit) {
    return sum - tx.amount; // Subtract income
  } else {
    return sum + tx.amount; // Add spending
  }
});
```

## Usage Examples

### Create and Save Transaction

```dart
import 'package:centabit/data/models/transaction_model.dart';
import 'package:centabit/data/repositories/transaction_repository.dart';

// Create transaction
final transaction = TransactionModel.create(
  name: 'Grocery Shopping',
  amount: 125.50,
  type: TransactionType.debit,
  categoryId: groceryCategoryId,
  budgetId: decemberBudgetId,
  notes: 'Weekly groceries',
);

// Save via repository
final repository = getIt<TransactionRepository>();
await repository.createTransaction(transaction);
```

### Update Transaction

```dart
// Fetch existing
final existing = await repository.getTransactionById(transactionId);

// Update category
final updated = existing!.copyWith(categoryId: newCategoryId);

// Save changes
await repository.updateTransaction(updated);
```

### Filter Transactions by Date Range

```dart
final startDate = DateTime(2024, 12, 1);
final endDate = DateTime(2024, 12, 31);

final decemberTransactions = repository.transactions.where((tx) {
  return !tx.transactionDate.isBefore(startDate) &&
         !tx.transactionDate.isAfter(endDate);
}).toList();
```

### Calculate Category Spending

```dart
final categorySpending = <String, double>{};

for (final tx in transactions) {
  if (tx.categoryId != null && tx.type == TransactionType.debit) {
    final categoryId = tx.categoryId!;
    categorySpending[categoryId] =
      (categorySpending[categoryId] ?? 0) + tx.amount;
  }
}
```

### Separate Budgeted vs Unassigned Transactions

```dart
final budgetedTxs = transactions
  .where((tx) => tx.budgetId != null)
  .toList();

final unassignedTxs = transactions
  .where((tx) => tx.budgetId == null)
  .toList();

print('Budgeted: ${budgetedTxs.length}');
print('Unassigned: ${unassignedTxs.length}');
```

## Relationships

### Many-to-One with Category

```
Transaction (N) ──> (1) Category
```

A transaction optionally references one category. Many transactions can share the same category.

**Access:**
```dart
// In Cubit (with denormalization)
final category = transaction.categoryId != null
  ? categoryRepository.getCategoryByIdSync(transaction.categoryId!)
  : null;

print('${transaction.name} - ${category?.name ?? "Uncategorized"}');
```

### Many-to-One with Budget

```
Transaction (N) ──> (1) Budget
```

A transaction optionally references one budget. Many transactions can belong to the same budget.

**Filtering:**
```dart
// Get transactions for specific budget
final budgetTransactions = repository.transactions
  .where((tx) => tx.budgetId == budgetId)
  .toList();
```

## Best Practices

### Use `.create()` for New Transactions
Always use the factory constructor for new instances:

```dart
// ✅ Good - auto-generates ID and timestamps
final tx = TransactionModel.create(
  name: 'Coffee',
  amount: 5.50,
  type: TransactionType.debit,
);

// ❌ Bad - requires manual ID and timestamp management
final tx = TransactionModel(
  id: Uuid().v4(),
  name: 'Coffee',
  amount: 5.50,
  type: TransactionType.debit,
  transactionDate: DateTime.now(),
  createdAt: DateTime.now(),
  updatedAt: DateTime.now(),
);
```

### Validate Amount is Positive
Amount should always be positive. Type determines direction:

```dart
// ✅ Good - positive amount with debit type
final spending = TransactionModel.create(
  name: 'Purchase',
  amount: 50.00,
  type: TransactionType.debit,
);

// ❌ Bad - negative amount (use credit type instead)
final badIncome = TransactionModel.create(
  name: 'Income',
  amount: -50.00, // Don't do this!
  type: TransactionType.debit,
);
```

### Assign Budgets for Tracking
For better budget tracking, assign transactions to budgets:

```dart
// ✅ Good - assigned to budget
final tracked = TransactionModel.create(
  name: 'Groceries',
  amount: 45.50,
  type: TransactionType.debit,
  budgetId: activeBudgetId, // Will count in budget
);

// ⚠️ Warning - unassigned (won't count in any budget)
final untracked = TransactionModel.create(
  name: 'Groceries',
  amount: 45.50,
  type: TransactionType.debit,
  budgetId: null, // Excluded from budget tracking
);
```

## See Also

- [BudgetModel](./budget-model.md) - Budget entity
- [CategoryModel](./category-model.md) - Category entity
- [TransactionRepository](../repositories/transaction-repository.md) - Data access
- [TransactionListCubit](../cubits/transaction-list-cubit.md) - State management
