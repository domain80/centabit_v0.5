# AllocationModel

Represents an allocation of budget funds to a specific category in Centabit.

## Overview

`AllocationModel` is an immutable domain model representing the distribution of budget funds across categories. Allocations connect budgets to categories with specific amounts, enabling detailed budget planning and tracking.

**Location:** `lib/data/models/allocation_model.dart`

## Concept

Allocations distribute a budget's total amount across different spending categories:

```
Budget ($2000) → Allocations:
  ├─ Groceries ($500)
  ├─ Dining ($300)
  ├─ Transportation ($200)
  └─ Entertainment ($150)
  Total: $1150 (unallocated: $850)
```

**Key characteristics:**
- Each allocation links one budget to one category
- Sum of allocations can be ≤ budget amount (allows unallocated funds)
- Used for budget planning and chart visualizations
- Compared against actual transaction spending

## Properties

### Core Fields

#### `id` (String, required)
Unique identifier (UUID v4).

Auto-generated by `.create()` factory. Used for updates and deletions.

```dart
final id = allocation.id; // "a1b2c3d4-e5f6-g7h8-i9j0-k1l2m3n4o5p6"
```

#### `amount` (double, required)
Amount allocated to this category in this budget.

Should be positive and typically less than the budget's total amount.

```dart
final amount = allocation.amount; // 500.00
```

**Guidelines:**
- Must be positive (`> 0`)
- Multiple allocations for same budget should sum to ≤ `budget.amount`
- Represents planned/budgeted spending, not actual spending

#### `categoryId` (String, required)
Reference to the category receiving this allocation.

Links to `CategoryModel.id`. Multiple budgets can allocate to the same category.

```dart
final categoryId = allocation.categoryId; // "cat-groceries-123"
```

#### `budgetId` (String, required)
Reference to the parent budget.

Links to `BudgetModel.id`. A budget can have multiple allocations (one per category).

```dart
final budgetId = allocation.budgetId; // "budget-dec-2025"
```

### Timestamp Fields

#### `createdAt` (DateTime, required)
Timestamp when allocation was created.

Auto-generated by `.create()` factory. Immutable after creation.

#### `updatedAt` (DateTime, required)
Timestamp when allocation was last modified.

Auto-generated by `.create()`. Updated automatically by `.withUpdatedTimestamp()`.

## Factory Constructors

### `AllocationModel.create()`

Creates a new allocation with auto-generated ID and timestamps.

**Signature:**
```dart
factory AllocationModel.create({
  required double amount,
  required String categoryId,
  required String budgetId,
})
```

**Parameters:**
- `amount` - Allocated amount (must be positive)
- `categoryId` - Target category ID (must exist)
- `budgetId` - Parent budget ID (must exist)

**Auto-generated:**
- `id` - New UUID v4
- `createdAt` - Current timestamp
- `updatedAt` - Current timestamp

**Example:**
```dart
// Create allocation for groceries
final allocation = AllocationModel.create(
  amount: 500.00,
  categoryId: groceryCategoryId,
  budgetId: decemberBudgetId,
);

// Create multiple allocations for same budget
final allocations = [
  AllocationModel.create(
    amount: 500.00,
    categoryId: groceryCategoryId,
    budgetId: budgetId,
  ),
  AllocationModel.create(
    amount: 300.00,
    categoryId: diningCategoryId,
    budgetId: budgetId,
  ),
  AllocationModel.create(
    amount: 200.00,
    categoryId: transportCategoryId,
    budgetId: budgetId,
  ),
];
```

### `AllocationModel.fromJson()`

Deserializes allocation from JSON map.

**Signature:**
```dart
factory AllocationModel.fromJson(Map<String, dynamic> json)
```

**Example:**
```dart
final json = {
  'id': 'a1b2c3d4-e5f6-g7h8-i9j0-k1l2m3n4o5p6',
  'amount': 500.00,
  'categoryId': 'cat-groceries-123',
  'budgetId': 'budget-dec-2025',
  'createdAt': '2025-11-28T10:00:00.000Z',
  'updatedAt': '2025-11-28T10:00:00.000Z',
};

final allocation = AllocationModel.fromJson(json);
```

## Methods

### `toJson()`

Serializes allocation to JSON map.

**Signature:**
```dart
Map<String, dynamic> toJson()
```

**Example:**
```dart
final json = allocation.toJson();
// {
//   'id': '...',
//   'amount': 500.00,
//   'categoryId': 'cat-groceries-123',
//   'budgetId': 'budget-dec-2025',
//   ...
// }
```

### `copyWith()`

Creates a copy with modified fields (Freezed-generated).

**Signature:**
```dart
AllocationModel copyWith({
  String? id,
  double? amount,
  String? categoryId,
  String? budgetId,
  DateTime? createdAt,
  DateTime? updatedAt,
})
```

**Example:**
```dart
// Update amount
final updated = allocation.copyWith(amount: 600.00);

// Change category
final reassigned = allocation.copyWith(categoryId: newCategoryId);

// Move to different budget
final moved = allocation.copyWith(budgetId: newBudgetId);
```

## Extension Methods

### `withUpdatedTimestamp()`

Returns a copy with updated timestamp.

**Signature:**
```dart
AllocationModel withUpdatedTimestamp()
```

**Returns:** New instance with `updatedAt` set to `DateTime.now()`.

**Example:**
```dart
// Update allocation with timestamp
final updated = allocation
  .withUpdatedTimestamp()
  .copyWith(amount: 600.00);

// Repository automatically uses this
Future<void> updateAllocation(AllocationModel model) async {
  final updatedModel = model.withUpdatedTimestamp();
  await _localSource.updateAllocation(_mapToDbModel(updatedModel));
}
```

### `isValidAmount()`

Validates that the allocation amount is positive.

**Signature:**
```dart
bool isValidAmount()
```

**Returns:** `true` if `amount > 0`, `false` otherwise.

**Example:**
```dart
final allocation = AllocationModel.create(
  amount: 500.00,
  categoryId: categoryId,
  budgetId: budgetId,
);

if (!allocation.isValidAmount()) {
  throw Exception('Allocation amount must be positive');
}

// Use in validation
void validateAllocation(AllocationModel allocation) {
  if (!allocation.isValidAmount()) {
    throw ArgumentError('Invalid allocation amount: ${allocation.amount}');
  }
}
```

## List Extension Methods

The `AllocationListExtensions` provides helper methods for working with lists of allocations.

### `totalAmount()`

Calculates the total amount across all allocations.

**Signature:**
```dart
double totalAmount()
```

**Example:**
```dart
final allocations = allocationRepository
  .getAllocationsForBudget(budgetId);

final totalAllocated = allocations.totalAmount();
print('Total allocated: \$${totalAllocated.toStringAsFixed(2)}');

// Check against budget amount
final budget = await budgetRepository.getBudgetById(budgetId);
final unallocated = budget.amount - allocations.totalAmount();
print('Unallocated: \$${unallocated.toStringAsFixed(2)}');
```

### `groupByCategory()`

Groups allocations by category ID.

**Signature:**
```dart
Map<String, List<AllocationModel>> groupByCategory()
```

**Returns:** Map where keys are category IDs, values are allocation lists.

**Example:**
```dart
final allocations = allocationRepository.allocations;
final byCategory = allocations.groupByCategory();

// Find all budget allocations for a category
final groceryAllocations = byCategory[groceryCategoryId] ?? [];

print('Grocery allocations across all budgets:');
for (final alloc in groceryAllocations) {
  print('  Budget ${alloc.budgetId}: \$${alloc.amount}');
}
```

### `groupByBudget()`

Groups allocations by budget ID.

**Signature:**
```dart
Map<String, List<AllocationModel>> groupByBudget()
```

**Returns:** Map where keys are budget IDs, values are allocation lists.

**Example:**
```dart
final allocations = allocationRepository.allocations;
final byBudget = allocations.groupByBudget();

// Display allocations per budget
for (final budgetId in byBudget.keys) {
  final budgetAllocs = byBudget[budgetId]!;
  final total = budgetAllocs.totalAmount();

  print('Budget $budgetId:');
  print('  ${budgetAllocs.length} allocations');
  print('  Total: \$${total.toStringAsFixed(2)}');
}
```

### `forBudget()`

Filters allocations for a specific budget.

**Signature:**
```dart
List<AllocationModel> forBudget(String budgetId)
```

**Example:**
```dart
final allAllocations = allocationRepository.allocations;
final decemberAllocations = allAllocations.forBudget(decemberBudgetId);

print('December budget has ${decemberAllocations.length} allocations');
```

### `forCategory()`

Filters allocations for a specific category.

**Signature:**
```dart
List<AllocationModel> forCategory(String categoryId)
```

**Example:**
```dart
final allAllocations = allocationRepository.allocations;
final groceryAllocations = allAllocations.forCategory(groceryCategoryId);

final totalGroceryBudget = groceryAllocations.totalAmount();
print('Total grocery allocation: \$${totalGroceryBudget}');
```

## Usage Examples

### Create Budget with Allocations

```dart
import 'package:centabit/data/models/budget_model.dart';
import 'package:centabit/data/models/allocation_model.dart';
import 'package:centabit/data/repositories/budget_repository.dart';
import 'package:centabit/data/repositories/allocation_repository.dart';

// 1. Create budget
final budget = BudgetModel.create(
  name: 'December 2025',
  amount: 2000.00,
  startDate: DateTime(2025, 12, 1),
  endDate: DateTime(2025, 12, 31, 23, 59, 59),
);
await budgetRepository.createBudget(budget);

// 2. Create allocations
final allocations = [
  AllocationModel.create(
    amount: 500.00,
    categoryId: groceryCategoryId,
    budgetId: budget.id,
  ),
  AllocationModel.create(
    amount: 300.00,
    categoryId: diningCategoryId,
    budgetId: budget.id,
  ),
  AllocationModel.create(
    amount: 200.00,
    categoryId: transportCategoryId,
    budgetId: budget.id,
  ),
  AllocationModel.create(
    amount: 150.00,
    categoryId: entertainmentCategoryId,
    budgetId: budget.id,
  ),
];

// Save allocations
for (final allocation in allocations) {
  await allocationRepository.createAllocation(allocation);
}

// Verify total
final totalAllocated = allocations.totalAmount(); // 1150.00
final unallocated = budget.amount - totalAllocated; // 850.00
print('Allocated: \$${totalAllocated}, Unallocated: \$${unallocated}');
```

### Update Allocation Amount

```dart
// Fetch existing
final allocation = await allocationRepository
  .getAllocationById(allocationId);

// Increase allocation
final updated = allocation!
  .withUpdatedTimestamp()
  .copyWith(amount: 600.00);

// Save
await allocationRepository.updateAllocation(updated);
```

### Calculate Budget Utilization

```dart
// Get budget and allocations
final budget = await budgetRepository.getBudgetById(budgetId);
final allocations = allocationRepository
  .getAllocationsForBudget(budgetId);

// Calculate metrics
final totalAllocated = allocations.totalAmount();
final unallocated = budget.amount - totalAllocated;
final allocationPercentage = (totalAllocated / budget.amount) * 100;

print('Budget: \$${budget.amount.toStringAsFixed(2)}');
print('Allocated: \$${totalAllocated.toStringAsFixed(2)} '
      '(${allocationPercentage.toStringAsFixed(1)}%)');
print('Unallocated: \$${unallocated.toStringAsFixed(2)}');
```

### Build Chart Data (Allocation vs Spending)

```dart
// Get allocations and transactions for budget
final allocations = allocationRepository
  .getAllocationsForBudget(budgetId);
final transactions = transactionRepository.transactions
  .where((tx) => tx.budgetId == budgetId)
  .toList();

// Build chart data per category
final chartData = categories.map((category) {
  // Find allocation for this category
  final allocation = allocations.firstWhere(
    (a) => a.categoryId == category.id,
    orElse: () => AllocationModel.create(
      amount: 0,
      categoryId: category.id,
      budgetId: budgetId,
    ),
  );

  // Sum transactions for this category
  final categorySpending = transactions
    .where((tx) => tx.categoryId == category.id)
    .fold<double>(0, (sum, tx) => sum + tx.amount);

  return TransactionsChartData(
    categoryId: category.id,
    categoryName: category.name,
    categoryIconName: category.iconName,
    allocationAmount: allocation.amount,
    transactionAmount: categorySpending,
  );
}).toList();
```

### Delete Budget with Allocations

```dart
// Delete all allocations first
final allocations = allocationRepository
  .getAllocationsForBudget(budgetId);

for (final allocation in allocations) {
  await allocationRepository.deleteAllocation(allocation.id);
}

// Then delete budget
await budgetRepository.deleteBudget(budgetId);
```

## Relationships

### Many-to-One with Budget

```
Allocation (N) ──> (1) Budget
```

Multiple allocations belong to one budget. Each allocation references a budget via `budgetId`.

**Access:**
```dart
final allocations = allocationRepository
  .getAllocationsForBudget(budgetId);

print('Budget has ${allocations.length} allocations');
```

### Many-to-One with Category

```
Allocation (N) ──> (1) Category
```

Multiple allocations can reference the same category (across different budgets). Each allocation references a category via `categoryId`.

**Access:**
```dart
final allocations = allocationRepository
  .getAllocationsForCategory(categoryId);

print('Category has ${allocations.length} allocations across budgets');
```

### Relationship Diagram

```
Budget (1) ──< (N) Allocations ──> (1) Category
```

Allocations connect budgets to categories in a many-to-many relationship pattern.

## Validation

### Amount Validation

```dart
void validateAllocation(AllocationModel allocation) {
  if (!allocation.isValidAmount()) {
    throw ArgumentError('Amount must be positive');
  }
}
```

### Budget Sum Validation

```dart
Future<void> validateBudgetAllocations(String budgetId) async {
  final budget = await budgetRepository.getBudgetById(budgetId);
  final allocations = allocationRepository
    .getAllocationsForBudget(budgetId);

  final totalAllocated = allocations.totalAmount();

  if (totalAllocated > budget.amount) {
    throw StateError(
      'Allocations (\$${totalAllocated}) exceed budget (\$${budget.amount})'
    );
  }
}
```

**Note:** Exceeding budget amount is typically a soft warning, not a hard error. Users may intentionally over-allocate to track overspending.

## Best Practices

### Use `.create()` for New Allocations
Always use the factory constructor:

```dart
// ✅ Good - auto-generates ID and timestamps
final allocation = AllocationModel.create(
  amount: 500.00,
  categoryId: categoryId,
  budgetId: budgetId,
);

// ❌ Bad - requires manual management
final allocation = AllocationModel(
  id: Uuid().v4(),
  amount: 500.00,
  categoryId: categoryId,
  budgetId: budgetId,
  createdAt: DateTime.now(),
  updatedAt: DateTime.now(),
);
```

### Validate Positive Amounts
Always ensure amounts are positive:

```dart
// ✅ Good - validate before creating
if (amount <= 0) {
  throw ArgumentError('Allocation amount must be positive');
}
final allocation = AllocationModel.create(
  amount: amount,
  categoryId: categoryId,
  budgetId: budgetId,
);

// Or use extension
if (!allocation.isValidAmount()) {
  throw ArgumentError('Invalid allocation');
}
```

### Allow Unallocated Funds
Budget amount can exceed sum of allocations:

```dart
// ✅ Good - budget provides flexibility
final budget = BudgetModel.create(
  name: 'December 2025',
  amount: 2000.00, // Total available
  ...
);

// Allocate only $1500, leaving $500 buffer
final allocations = [
  AllocationModel.create(amount: 500.00, ...),
  AllocationModel.create(amount: 500.00, ...),
  AllocationModel.create(amount: 500.00, ...),
];

final unallocated = budget.amount - allocations.totalAmount(); // $500
```

### One Allocation per Category per Budget
Typically, each budget should have at most one allocation per category:

```dart
// ✅ Good - one allocation per category
final allocations = [
  AllocationModel.create(
    amount: 500.00,
    categoryId: groceryCategoryId,
    budgetId: budgetId,
  ),
  AllocationModel.create(
    amount: 300.00,
    categoryId: diningCategoryId,
    budgetId: budgetId,
  ),
];

// ❌ Bad - duplicate category in same budget
final duplicates = [
  AllocationModel.create(
    amount: 300.00,
    categoryId: groceryCategoryId, // Duplicate
    budgetId: budgetId,
  ),
  AllocationModel.create(
    amount: 200.00,
    categoryId: groceryCategoryId, // Duplicate
    budgetId: budgetId,
  ),
];
```

## See Also

- [BudgetModel](./budget-model.md) - Parent budget entity
- [CategoryModel](./category-model.md) - Target category entity
- [AllocationRepository](../repositories/allocation-repository.md) - Data access
- [DashboardCubit](../cubits/dashboard-cubit.md) - Chart data building
